{% extends "base.html" %} 
{% block title %}Sheffield Temperature Sensor Network{% endblock %} 
{% block content %}

<div id="map"></div>

<link
  rel="stylesheet"
  href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css"
/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.heat/0.2.0/leaflet-heat.js"></script>

<style>
  .container {
    max-width: 1200px;
    margin: 20px auto;
    padding: 20px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
    background: white;
  }
  #map {
    width: 100%;
    height: 700px;
    border-radius: 4px;
  }
  .legend i {
    width: 18px;
    height: 18px;
    display: inline-block;
    margin-right: 5px;
  }
</style>

<script>
  var map = L.map("map").setView([53.3811, -1.4701], 14);

  L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    {
      maxZoom: 19,
      attribution:
        "Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",
    }
  ).addTo(map);

  function generateHeatData() {
    var points = [];
    var centerLat = 53.3811;
    var centerLng = -1.4701;
    var numPoints = 1000;

    for (var i = 0; i < numPoints; i++) {
      var angle = Math.random() * Math.PI * 2;
      var radius = Math.random() * 0.015;
      var lat = centerLat + radius * Math.cos(angle);
      var lng = centerLng + radius * Math.sin(angle);
      var distToCenter = Math.sqrt(
        Math.pow(lng - centerLng, 2) + Math.pow(lat - centerLat, 2)
      );
      var intensity = Math.max(0.3, 1 - distToCenter * 25);
      intensity += (Math.random() - 0.5) * 0.2;
      intensity = Math.max(0.3, Math.min(1, intensity));
      points.push([lat, lng, intensity]);
    }
    return points;
  }

  var heatData = generateHeatData();
  var heat = L.heatLayer(heatData, {
    radius: 25,
    blur: 15,
    maxZoom: 17,
    max: 1.0,
    gradient: {
      0.4: "rgba(49, 54, 149, 0.8)",
      0.5: "rgba(69, 117, 180, 0.8)",
      0.6: "rgba(116, 173, 209, 0.8)",
      0.7: "rgba(171, 217, 233, 0.8)",
      0.8: "rgba(254, 224, 144, 0.8)",
      0.9: "rgba(253, 174, 97, 0.8)",
      1.0: "rgba(215, 48, 39, 0.8)",
    },
  }).addTo(map);

  var legend = L.control({ position: "bottomright" });
  legend.onAdd = function (map) {
    var div = L.DomUtil.create("div", "legend");
    div.innerHTML += "<h4>Temperature</h4>";
    div.innerHTML += '<i style="background: #313695"></i>15째C<br>';
    div.innerHTML += '<i style="background: #74add1"></i>20째C<br>';
    div.innerHTML += '<i style="background: #fee090"></i>25째C<br>';
    div.innerHTML += '<i style="background: #d73027"></i>30째C<br>';
    return div;
  };
  legend.addTo(map);

// Function to fetch and overlay rivers dynamically
function fetchRivers() {
    var bounds = map.getBounds();
    var minLat = bounds.getSouth();
    var minLng = bounds.getWest();
    var maxLat = bounds.getNorth();
    var maxLng = bounds.getEast();

    // Construct Overpass API query
    var overpassQuery = `
        [out:json];
        way[waterway=river](${minLat},${minLng},${maxLat},${maxLng});
        out geom;
    `;
    var overpassURL = "https://overpass-api.de/api/interpreter?data=" + encodeURIComponent(overpassQuery);

    fetch(overpassURL)
        .then(response => response.json())
        .then(data => {
            // Convert Overpass API data to valid GeoJSON
            var geojson = {
                "type": "FeatureCollection",
                "features": data.elements
                    .filter(element => element.type === "way" && element.geometry)
                    .map(element => ({
                        "type": "Feature",
                        "geometry": {
                            "type": "LineString",
                            "coordinates": element.geometry.map(coord => [coord.lon, coord.lat])
                        },
                        "properties": {
                            "id": element.id
                        }
                    }))
            };

            // Remove previous river layer (if any)
            if (window.riverLayer) {
                map.removeLayer(window.riverLayer);
            }

            // Add the new rivers as a GeoJSON layer
            window.riverLayer = L.geoJSON(geojson, {
                style: {
                    color: "red",  // Bright red rivers
                    weight: 3,
                    opacity: 1
                }
            }).addTo(map);

            window.riverLayer.bringToFront();
        })
        .catch(error => console.error("Error loading river data:", error));
}

// Initial fetch on map load
map.on("load", fetchRivers);

// Fetch rivers when the user moves the map
map.on("moveend", fetchRivers);

</script>

{% endblock %}
